---
title: "Salm Project"
author: "Clement poupelin"
date: "2024-04-02"
output: html_document
---


```{r}
Ndoses = 6                                          
Nplates = 3                                         
x = c(0, 10, 33, 100, 333, 1000)
i1 = c(15, 16, 16, 27, 33, 20)
i2 = c(21, 18, 26, 41, 38, 27)
i3 = c(29, 21, 33, 69, 41, 42)
y = structure(c(15, 16, 16, 27, 33, 20, 21, 18, 26, 41, 38, 27, 29, 
                 21, 33, 60, 41, 42), .Dim = c(6, 3))
             
```


```{r}
alpha <- 0
beta <- 0
gamma <- 0
tau <- 0.1
lambda <-structure(c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 
                   .Dim = c(6, 3))
```

We implement the model:

```{r}
model <- function(Ndoses, Nplates, x, y, alpha, beta, gamma, tau, lambda, 
                  nchain, prop_sd){
  ## Hyperparameters
  alpha.sigma2 <- .000001
  beta.sigma2 <- .000001
  gamma.sigma2 <- .000001
  tau.xi <- .001
  tau.phi <- .001
  
  ## Initialization
  mu <- matrix(NA, nrow = Ndoses, ncol = Nplates)
  mu.candidate <- matrix(NA, nrow = Ndoses, ncol = Nplates)
  chain <- matrix(NA, nrow = nchain + 1, ncol = 4)
  colnames(chain) <- c("alpha", "beta", "gamma", "tau")
  chain[1,] <- c(alpha, beta, gamma, tau)
  
  ## Update
  for(k in 1:nchain){
    
    ## tau update 
    ############################
    tau.rate <- tau.xi + Ndoses*Nplates
    tau.shape <- 1/tau.phi + .5*sum(lambda**2)
    tau <- rgamma(n = 1, rate = tau.rate, shape = tau.shape)
    chain[k + 1, 4] <- tau
    lambda <- structure(rnorm(n = Nplates * Ndoses, mean = 0, sd = sqrt(chain[k + 1, 4])), .Dim = c(Ndoses, Nplates))
    for(j in 1:Ndoses){
      for(i in 1:Nplates){
        mu[j, i] <- exp(chain[k, 1] + chain[k, 2] * log(x[j] + 10) + chain[k, 3] * x[j] + lambda[j, i])
      }
    }
    
    ## alpha beta gamma update
    ##############################
    
    # Metropolis-Hastings for alpha
    alpha.candidate <- rnorm(1, mean = chain[k, 1], sd = prop_sd[1])
    for(j in 1:Ndoses){
      for(i in 1:Nplates){
        mu.candidate[j, i] <- exp(alpha.candidate + chain[k, 2] * log(x[j] + 10) + chain[k, 3] * x[j] + lambda[j, i])
      }
    }
    alpha.top <- alpha.candidate^2 / (-2*alpha.sigma2) + sum(y * log(mu.candidate) - mu.candidate)
    alpha.bottom <- - chain[k, 1]^2 / (-2*alpha.sigma2) + sum(y * log(mu) - mu)
    alpha.ratio <- alpha.top - alpha.bottom
    if(!is.na(alpha.ratio) && log(runif(1)) < alpha.ratio){
      chain[k + 1, 1] <- alpha.candidate
    } else {
      chain[k + 1, 1] <- chain[k, 1]
    }
    for(j in 1:Ndoses){
      for(i in 1:Nplates){
        mu[j, i] <- exp(chain[k+1, 1] + chain[k, 2] * log(x[j] + 10) + chain[k, 3] * x[j] + lambda[j, i])
      }
    }
    
    # Metropolis-Hastings for beta
    beta.candidate <- rnorm(1, mean = chain[k, 2], sd = prop_sd[2])
    for(j in 1:Ndoses){
      for(i in 1:Nplates){
        mu.candidate[j, i] <- exp(chain[k+1,1] + beta.candidate * log(x[j] + 10) + chain[k, 3] * x[j] + lambda[j, i])
      }
    }
    beta.top <- beta.candidate^2 / (-2*beta.sigma2) + sum(y * log(mu.candidate) - mu.candidate)
    beta.bottom <- chain[k, 2]^2 / (-2*beta.sigma2) + sum(y * log(mu) - mu)
    beta.ratio <- beta.top - beta.bottom
    if(!is.na(beta.ratio) && log(runif(1)) < beta.ratio){
      chain[k + 1, 2] <- beta.candidate
    } else {
      chain[k + 1, 2] <- chain[k, 2]
    }
    for(j in 1:Ndoses){
      for(i in 1:Nplates){
        mu[j, i] <- exp(chain[k+1, 1] + chain[k+1, 2] * log(x[j] + 10) + chain[k, 3] * x[j] + lambda[j, i])
      }
    }
    
    # Metropolis-Hastings for gamma
    gamma.candidate <- rnorm(1, mean = chain[k, 3], sd = prop_sd[3])
    for(j in 1:Ndoses){
      for(i in 1:Nplates){
        mu.candidate[j, i] <- exp(chain[k+1, 1] + chain[k+1, 2] * log(x[j] + 10) + gamma.candidate * x[j] + lambda[j, i])
      }
    }
    gamma.top <- gamma.candidate^2 / (-2*gamma.sigma2) + sum(y * log(mu.candidate) - mu.candidate)
    gamma.bottom <- chain[k, 3]^2 / (-2*gamma.sigma2) + sum(y * log(mu) - mu)
    gamma.ratio <- gamma.top - gamma.bottom
    if(!is.na(gamma.ratio) && log(runif(1)) < gamma.ratio){
      chain[k + 1, 3] <- gamma.candidate
    } else {
      chain[k + 1, 3] <- chain[k, 3]
    }
    for(j in 1:Ndoses){
      for(i in 1:Nplates){
        mu[j, i] <- exp(chain[k+1, 1] + chain[k+1, 2] * log(x[j] + 10) + chain[k+1, 3] * x[j] + lambda[j, i])
      }
    }
    
    
  }
  vec <- 1/chain[,4]
  chain.new <- cbind(chain[,1:3],vec)
  colnames(chain.new) <- c("alpha", "beta", "gamma", "sigma")
  return(chain.new)
}
```

```{r}
nchain <- 5000

prop_sd <-  c(0.1,0.1,0.1)
#prop_sd <-  c(0.01,0.01,0.01)
#prop_sd <-  c(1,1,1)
#prop_sd <-  c(2,2,2)
#prop_sd <-  c(15,15,15) #tres mauvais
#prop_sd <- c(1e-6, 1e-6, 1e-6) #tres mauvais
chain <- model(Ndoses, Nplates, x, y, alpha, beta, gamma, tau, lambda, nchain, prop_sd)
```

```{r, message=FALSE}
library(coda)
chain.new <- chain[1001:5000,]
plot(mcmc(chain.new[,1]))
plot(mcmc(chain.new[,2]))
plot(mcmc(chain.new[,3]))
plot(mcmc(chain.new[,4]))
```

```{r} 
chain <- chain[1001:4001,]
res = data.frame(
  mean = round(apply(chain, 2, mean), 4),
  sd = round(apply(chain, 2, sd), 4)
)
print(res)
```



```{r}
lbda = mean(rnorm(1, 0, 0.009))
lbda
mu = exp(-7.5 -0.09*log(10 + 10) - 0.08*10 + lbda)
mu
y = rpois(1, lbda)
y
```

